/* eslint-disable */

//
// Perlin noise module.
//
// Written by Thom Chiovoloni, dedicated into the public domain (as explained at
// http://creativecommons.org/publicdomain/zero/1.0/).
//

function gen() {
  function buildTable(randFunc?: Function) {
    if (!randFunc) {
      randFunc = Math.random
    }
    // @NOTE(thom): could optimize this for allocations, but it
    // shouldn't be near anybody's fast path...
    let arr = new Array(256).map((v, i) => {
      return i
    })
    // shuffle numbers 0 through 255
    for (let i = arr.length - 1; i > 0; --i) {
      let r = Math.floor(randFunc() * (i + 1))
      let t = arr[r]
      arr[r] = arr[i]
      arr[i] = t
    }
    return arr
  }

  let gradBasis = [
    1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0,
    -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1,
  ]

  function initTables(tab, permTable, gradTable) {
    if (tab == null || typeof tab === `function`) {
      tab = buildTable()
    } else if (tab.length !== 256) {
      tab = buildTable()
    }
    for (var i = 0; i < 256; ++i) {
      permTable[i] = tab[i]
      permTable[i + 256] = tab[i]
    }
    let gradIdx = 0
    for (var i = 0; i < permTable.length; ++i) {
      let v = (permTable[i] % 12) * 3
      gradTable[gradIdx++] = gradBasis[v]
      gradTable[gradIdx++] = gradBasis[v + 1]
      gradTable[gradIdx++] = gradBasis[v + 2]
    }
  }

  let permTableSize = 256 * 2
  let gradTableSize = permTableSize * 3
  let totalSize = permTableSize + gradTableSize

  //
  // function quickNoise.create(tableOrRng=Math.random);
  //
  // `tableOrRng` must either be:
  //
  // - A function that takes 0 arguments and returns a uniformly distributed
  //   random number between 0 and 1 (like `Math.random`).
  // - An array of length 256, where the array is generated by shuffling all
  //   integers between 0 and 255 (inclusive).
  //
  // If no argument (or a bad argument) is provided, it defaults to Math.random.
  //
  // This creates a perlin noise generation function. For more documentation about
  // the function returned by this call, see the documentation for `quickNoise.noise`, below.
  //
  // If you provide a function, this will be used only to generate the permutation table, and
  // will not be called after this function returns.
  //
  // The array argument provided in case you want to provide a specific permutation table.
  //

  function create(tab) {
    let ab = new ArrayBuffer(totalSize)
    let permTable = new Uint8Array(ab, 0, permTableSize)
    let gradTable = new Int8Array(ab, permTableSize, gradTableSize)
    initTables(tab, permTable, gradTable)

    function noise(
      x: number,
      y: number,
      z = 0,
      xWrap = 0,
      yWrap = 0,
      zWrap = 0,
    ) {
      // coersce to integers and handle missing arguments
      xWrap |= 0
      yWrap |= 0
      zWrap |= 0

      // type hints for vm
      x = Number(x)
      y = Number(y)
      z = Number(z)

      let xMask = ((xWrap - 1) & 255) >>> 0
      let yMask = ((yWrap - 1) & 255) >>> 0
      let zMask = ((zWrap - 1) & 255) >>> 0

      let px = Math.floor(x)
      let py = Math.floor(y)
      let pz = Math.floor(z)

      let x0 = (px + 0) & xMask
      let x1 = (px + 1) & xMask

      let y0 = (py + 0) & yMask
      let y1 = (py + 1) & yMask

      let z0 = (pz + 0) & zMask
      let z1 = (pz + 1) & zMask

      x -= px
      y -= py
      z -= pz

      let u = ((x * 6.0 - 15.0) * x + 10.0) * x * x * x
      let v = ((y * 6.0 - 15.0) * y + 10.0) * y * y * y
      let w = ((z * 6.0 - 15.0) * z + 10.0) * z * z * z

      let r0 = permTable[x0]
      let r1 = permTable[x1]

      let r00 = permTable[r0 + y0]
      let r01 = permTable[r0 + y1]
      let r10 = permTable[r1 + y0]
      let r11 = permTable[r1 + y1]

      let h000 = permTable[r00 + z0] * 3
      let h001 = permTable[r00 + z1] * 3
      let h010 = permTable[r01 + z0] * 3
      let h011 = permTable[r01 + z1] * 3
      let h100 = permTable[r10 + z0] * 3
      let h101 = permTable[r10 + z1] * 3
      let h110 = permTable[r11 + z0] * 3
      let h111 = permTable[r11 + z1] * 3

      let n000 =
        gradTable[h000] * (x + 0) +
        gradTable[h000 + 1] * (y + 0) +
        gradTable[h000 + 2] * (z + 0)
      let n001 =
        gradTable[h001] * (x + 0) +
        gradTable[h001 + 1] * (y + 0) +
        gradTable[h001 + 2] * (z - 1)
      let n010 =
        gradTable[h010] * (x + 0) +
        gradTable[h010 + 1] * (y - 1) +
        gradTable[h010 + 2] * (z + 0)
      let n011 =
        gradTable[h011] * (x + 0) +
        gradTable[h011 + 1] * (y - 1) +
        gradTable[h011 + 2] * (z - 1)
      let n100 =
        gradTable[h100] * (x - 1) +
        gradTable[h100 + 1] * (y + 0) +
        gradTable[h100 + 2] * (z + 0)
      let n101 =
        gradTable[h101] * (x - 1) +
        gradTable[h101 + 1] * (y + 0) +
        gradTable[h101 + 2] * (z - 1)
      let n110 =
        gradTable[h110] * (x - 1) +
        gradTable[h110 + 1] * (y - 1) +
        gradTable[h110 + 2] * (z + 0)
      let n111 =
        gradTable[h111] * (x - 1) +
        gradTable[h111 + 1] * (y - 1) +
        gradTable[h111 + 2] * (z - 1)

      let n00 = n000 + (n001 - n000) * w
      let n01 = n010 + (n011 - n010) * w
      let n10 = n100 + (n101 - n100) * w
      let n11 = n110 + (n111 - n110) * w

      let n0 = n00 + (n01 - n00) * v
      let n1 = n10 + (n11 - n10) * v

      return n0 + (n1 - n0) * u + 1
    }
    return noise
  }

  //
  // function quickNoise.noise(x, y, z, xWrap=0, yWrap=0, zWrap=0);
  //
  // - `x`, `y`, `z` are numbers.
  // - `xWrap`, `yWrap`, and `zWrap` are integer powers of two between 0 and 256.
  //   (0 and 256 are equivalent). If these aren't provided, they default to 0.
  //
  // This implements Ken Perlin's revised noise function from 2002, in 3D. It
  // computes a random value for the coordinate `x`, `y`, `z`, where adjacent
  // values are continuous with a period of 1 (Values at integer points are
  // entirely unrelated).
  //
  // This function is seeded. That is, it will return the same results when
  // called with the same arguments, across successive program runs. An unseeded
  // version may be created with the `quickNoise.create` function. The table it is
  // seeded is the one from the `stb_perlin.h` library.
  //
  let noise = create([
    23, 125, 161, 52, 103, 117, 70, 37, 247, 101, 203, 169, 124, 126, 44, 123,
    152, 238, 145, 45, 171, 114, 253, 10, 192, 136, 4, 157, 249, 30, 35, 72,
    175, 63, 77, 90, 181, 16, 96, 111, 133, 104, 75, 162, 93, 56, 66, 240, 8,
    50, 84, 229, 49, 210, 173, 239, 141, 1, 87, 18, 2, 198, 143, 57, 225, 160,
    58, 217, 168, 206, 245, 204, 199, 6, 73, 60, 20, 230, 211, 233, 94, 200, 88,
    9, 74, 155, 33, 15, 219, 130, 226, 202, 83, 236, 42, 172, 165, 218, 55, 222,
    46, 107, 98, 154, 109, 67, 196, 178, 127, 158, 13, 243, 65, 79, 166, 248,
    25, 224, 115, 80, 68, 51, 184, 128, 232, 208, 151, 122, 26, 212, 105, 43,
    179, 213, 235, 148, 146, 89, 14, 195, 28, 78, 112, 76, 250, 47, 24, 251,
    140, 108, 186, 190, 228, 170, 183, 139, 39, 188, 244, 246, 132, 48, 119,
    144, 180, 138, 134, 193, 82, 182, 120, 121, 86, 220, 209, 3, 91, 241, 149,
    85, 205, 150, 113, 216, 31, 100, 41, 164, 177, 214, 153, 231, 38, 71, 185,
    174, 97, 201, 29, 95, 7, 92, 54, 254, 191, 118, 34, 221, 131, 11, 163, 99,
    234, 81, 227, 147, 156, 176, 17, 142, 69, 12, 110, 62, 27, 255, 0, 194, 59,
    116, 242, 252, 19, 21, 187, 53, 207, 129, 64, 135, 61, 40, 167, 237, 102,
    223, 106, 159, 197, 189, 215, 137, 36, 32, 22, 5,
  ])

  return {
    create: create,
    noise: noise,
  }
}

export const noise = gen().noise

const memoedStars = new Map<string, [number, number, number][]>()
export function getStars(
  x: number,
  y: number,
  density = 10,
): [number, number, number][] {
  x = Math.floor(x)
  y = Math.floor(y)
  const key = `${x},${y}`
  if (memoedStars.has(key)) {
    return memoedStars.get(key) || []
  }

  const stars: [number, number, number][] = []
  const densityMod = noise(x / 100, y / 100, 0.05) //(x + 3.41) * 0.23, (y + 1.23) * 0.41)
  const starCount = Math.floor(density * densityMod ** 2)

  for (let i = 0; i < starCount; i++) {
    let starZeroedX = noise(
      (i + 3.41) * 0.23 * x,
      (i + 1.23) * 0.41 * y,
      x * 0.14 + y * 2.13 + 4.33,
    )
    let starZeroedY = noise(
      (i + 4.32) * 0.14 * y,
      (i + 2.14) * 0.32 * x,
      x * 0.14 + y * 2.13 + 1.11,
    )
    let starZ = noise(
      (i + 5.42) * 1.24 * y,
      (i + 3.12) * 1.35 * x,
      x * 1.23 + y * 3.41 + 2.31,
    )
    stars.push([x + starZeroedX, y + starZeroedY, starZ])
  }

  memoedStars.set(key, stars)

  return stars
}
